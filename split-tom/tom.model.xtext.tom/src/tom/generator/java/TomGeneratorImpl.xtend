/*
 * generated by Xtext
 */
package tom.generator.java

import org.eclipse.emf.common.CommonPlugin
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import tom.Affectation
import tom.AntiPattern
import tom.AnyPattern
import tom.Argument
import tom.ArgumentMatch
import tom.ArgumentTypePrefix
import tom.ArgumentTypeSuffix
import tom.Arguments
import tom.ArgumentsList
import tom.Call
import tom.ConstraintAction
import tom.ConstraintAnd
import tom.ConstraintMatch
import tom.ConstraintOp
import tom.ConstraintOr
import tom.ConstraintP
import tom.ConstraintPattern
import tom.Declaration
import tom.ElementaryTransformation
import tom.ElementaryTransformationRule
import tom.ExplicitTermList
import tom.Expression
import tom.GomConstruct
import tom.HostCode
import tom.ImplicitPairList
import tom.ImportConstruct
import tom.IncludeConstruct
import tom.JokerPattern
import tom.MatchPattern
import tom.NamedPattern
import tom.OperationList
import tom.PairPattern
import tom.PatternAction
import tom.PatternList
import tom.PlainPatternConst
import tom.PlainPatternOperation
import tom.PlainPatternVariable
import tom.PlainPatternVariableList
import tom.RelOperator
import tom.Resolve
import tom.Return
import tom.StrategyConstruct
import tom.StrategyVisit
import tom.TermConst
import tom.TermNull
import tom.TermOperation
import tom.TermSum
import tom.TermVariable
import tom.Tom
import tom.Tracelink
import tom.Transformation
import tom.TypeDefinition
import tom.TypeTerm
import tom.VisitAction
import tom.XMLAttrList
import tom.XMLAttribute1
import tom.XMLAttribute2
import tom.XMLAttribute3
import tom.XMLChilds
import tom.XMLNameList
import tom.XMLTermComment
import tom.XMLTermDouble
import tom.XMLTermProcess
import tom.XMLTermSimple
import tom.XMLTermText
import tom.generator.TomGenerator

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
abstract class TomGeneratorImpl implements TomGenerator {
	
	override getCode() {
		"-j"
	}
	
	def String dirName(Resource r){
		val base = CommonPlugin.resolve(r.URI).toFileString
		base.substring(0,base.lastIndexOf("/")+1);
	}
	def String fileName(Resource r,String after){r.URI.lastSegment.substring(0,r.URI.lastSegment.indexOf('.'))+after}

	def Tom getTom(EObject o){
		if (o instanceof Tom) o else o.eContainer?.getTom
	}
	
	def dispatch String compile(RelOperator op){
		switch(op){
			case INF : '<'
			case INFEG: '<='
			case EG : '=='
			case SUP: '>'
			case SUPEG: '>='
			case NEG : '!='
		}	
	}
	
	def dispatch String compile(String ident)'''«ident.toString»'''
	def dispatch String compile(Void x){''}
	def dispatch String compile(IncludeConstruct include)'''%include{«include.importURI»«IF include.ext!=null».«include.ext»«ELSE».tom«ENDIF»}'''
	def dispatch String compile(ImportConstruct impor){''}
//Statement //////////////////////////////////////////////////////////////////////////////////////////
	def dispatch String fullCompile(Void x){''}
	def dispatch String fullCompile(TermVariable term)'''`«term.^var.name»'''
	def dispatch String fullCompile(TermOperation term)'''`«term.op.name»(«term.terms.map[compile].join(", ")»)'''
	def dispatch String fullCompile(TermSum term)'''«term.left.fullCompile» + «term.right.fullCompile»'''
	def dispatch String compile(TermSum term)'''«term.left.compile» + «term.right.compile»'''
	def dispatch String fullCompile(TermNull term){term.compile}
	def dispatch String compile(TermNull term)'''null'''
	
	
	def dispatch String fullCompile(Call e)'''«e.call.fullCompile»;'''
	def dispatch String fullCompile(Declaration a)'''«a.type.fullCompile» «a.name» = «a.value.fullCompile»;'''
	def dispatch String fullCompile(Affectation a)'''«a.variable.name» = «a.value.fullCompile»;'''
	def dispatch String fullCompile(TermConst a){a.compile}
	
	
	def dispatch String fullCompile(Return r)'''return «r.^return.fullCompile»;'''
	def dispatch String fullCompile(MatchPattern match){match.compile}
	def dispatch String fullCompile(ConstraintPattern match){match.compile}
	
	def dispatch String fullCompile(Arguments args)'''«args.args.map[fullCompile].join(", ")» '''
	def dispatch String fullCompile(ArgumentTypePrefix arg)'''«arg.type.fullCompile» «arg.name.compile»'''
	def dispatch String fullCompile(ArgumentTypeSuffix arg)'''«arg.name.compile»:«arg.type.fullCompile»'''
	def dispatch String fullCompile(HostCode hc){hc.code+"\n"}
	
	def dispatch String fullCompile(TypeTerm type)'''«type.hote»'''
	def dispatch String fullCompile(TypeDefinition type){
		(type.getTom.namespace+"."+type.eResource.fileName('tom.')+(type.eContainer as GomConstruct).name+".types.").toLowerCase+type.name
	}
	
	def dispatch String fullCompile(Tracelink tl)'''%tracelink(«tl.name»:«tl.type.name»,«tl.term.fullCompile»)'''
	def dispatch String fullCompile(Resolve r)'''%resolve(«r.source.name»:«r.type.name»,«r.target.name»:«r.target.type.name»)'''
	

/////////////////////////////////////////////////////////////////////////////////////////////////////
//Term //////////////////////////////////////////////////////////////////////////////////////////
	
	def dispatch String compile(TermVariable term)'''«term.^var.name»'''
	def dispatch String compile(TermOperation term)'''«term.op.name»(«term.terms.map[compile].join(", ")»)'''
	def dispatch String compile(TermConst a)'''«IF a.string!=null»"«a.string»"«ELSE»«a.^int»«ENDIF»'''
	
	def dispatch String compile(Expression e)'''/*Expression*/'''
	def dispatch String compile(Declaration a)'''«a.fullCompile»'''
	def dispatch String compile(Affectation a)'''«a.fullCompile»'''
/////////////////////////////////////////////////////////////////////////////////////////////////////
//Match //////////////////////////////////////////////////////////////////////////////////////////
	
	def dispatch String compile(MatchPattern match)'''
%match(«match.args.map[compile].join(", ")»){
	«match.patternActions.map[compile].join("\n")»
}
	'''
	def dispatch String compile(ArgumentMatch arg)'''«IF arg.type != null»«arg.type.name»«ENDIF» «arg.^var.name»'''
	def dispatch String compile(PatternAction action)'''«IF action.name != null»«action.name»:«ENDIF»«action.patterns.compile»->{«action.statements.map[fullCompile].join(" ")»}'''	
	def dispatch String compile(ConstraintPattern match)'''
%match{
	«match.constraintActions.map[compile].join("\n")»
}
	'''
	def dispatch String compile(ConstraintAction action)'''«action.constraint.compile»->{«action.statements.map[fullCompile].join("\n")»}'''
/////////////////////////////////////////////////////////////////////////////////////////////////////
//Strategy //////////////////////////////////////////////////////////////////////////////////////////
	def dispatch String compile(StrategyConstruct strategy)'''
%strategy «strategy.name»(«strategy.args.compile»)extends «strategy.implement.compile» {
	«strategy.visitlist.map[compile].join("\n")»
}
	'''
	
	def dispatch String compile(Arguments args)'''«args.args.map[compile].join(", ")» '''
	def dispatch String compile(ArgumentTypePrefix arg)'''«arg.type.name» «arg.name.compile»'''
	def dispatch String compile(ArgumentTypeSuffix arg)'''«arg.name.compile»:«arg.type.name»'''
	
	def dispatch String compile(Argument arg)'''«arg.name»'''
	
	def dispatch String compile(StrategyVisit sVisit)'''
visit «sVisit.type.name»{
	«sVisit.actions.map[compile].join("\n")»
}
	'''
	def dispatch String compile(VisitAction action)'''«action.pattern.compile»->«IF action.term != null»«action.term.compile» «ELSE»{«action.statements.map[fullCompile].join("\n")»}«ENDIF»'''
	def dispatch String compile(PatternList plist)'''«plist.patterns.map[compile].join(",")»«IF plist.constraint != null»«plist.rel»«plist.constraint.compile»«ENDIF»'''
	def dispatch String compile(ConstraintOr c)'''«c.left.compile»||«c.right.compile»'''
	def dispatch String compile(ConstraintAnd c)'''«c.left.compile»&&«c.right.compile»'''
	def dispatch String compile(ConstraintOp co)'''«co.left.compile» «co.operator.compile» «co.right.compile»'''
	def dispatch String compile(ConstraintMatch cm)'''«cm.pattern.compile»<<«IF cm.type != null»«cm.type.name» «ENDIF»«cm.term.compile»'''
	def dispatch String compile(ConstraintP cp)'''(«cp.constraint.compile»)'''
///////////////////////////////////////////////////////////////////////////////////////////////////	
//Pattern //////////////////////////////////////////////////////////////////////////////////////////
	def dispatch String compile(NamedPattern pattern)'''«pattern.name»@«pattern.plainPattern.compile»'''
	def dispatch String compile(AntiPattern ap)'''!«ap.pattern.compile»'''
	def dispatch String compile(PlainPatternConst pc)'''«pc.head.compile»'''
	def dispatch String compile(PlainPatternVariable pv)'''«pv.name.compile»'''
	def dispatch String compile(PlainPatternOperation po)'''«po.heads.compile»«po.list.compile»'''
	def dispatch String compile(OperationList op)'''«IF op.heads.size >1»(«op.heads.map[name].join("|")»)«ELSE»«op.heads.head.name»«IF op.log»?«ENDIF»«ENDIF»'''
	def dispatch String compile(ExplicitTermList list)'''(«list.patterns.map[compile].join(",")»)'''
	def dispatch String compile(ImplicitPairList list)'''[«list.patterns.map[compile].join(",")»]'''
	def dispatch String compile(PairPattern pair)'''«pair.name»=«pair.pattern.compile»'''
	def dispatch String compile(PlainPatternVariableList pvl)'''«pvl.name.compile»'''
	def dispatch String compile(AnyPattern p)'''_*'''
	def dispatch String compile(JokerPattern p)'''_'''
/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////Type/////////////////////////////////////////////////////////////////////////////////////
def dispatch String compile(ArgumentsList list)'''«list.type.name»*'''
	def dispatch String compile(TypeTerm type)'''
%typeterm «type.name»{
	implement{«type.hote»}
	«type.keys.map[compile].join("\n")»
}'''
//XML //////////////////////////////////////////////////////////////////////////////////////////
	def dispatch String compile(XMLTermSimple xml)'''< «xml.nameList.compile» «xml.attrList.compile» />'''
	def dispatch String compile(XMLTermDouble xml)'''< «xml.nameList.compile» «xml.attrList.compile» >«xml.childs.compile»</«xml.list.compile»>'''
	def dispatch String compile(XMLTermText xml)'''#TEXT(«xml.name»)'''
	def dispatch String compile(XMLTermComment xml)'''#COMMENT(«xml.name»)'''
	def dispatch String compile(XMLTermProcess xml)'''#PROCESSING-INSTRUCTION(«xml.name1», «xml.name2»)'''
	def dispatch String compile(XMLNameList xml)'''(«xml.XMLName.map[compile].join("|")»)'''
	def dispatch String compile(XMLAttrList xml)'''(«xml.attrs.map[compile].join(",")»)'''
	def dispatch String compile(XMLAttribute1 xml)'''«xml.name»*'''
	def dispatch String compile(XMLAttribute2 xml)'''«xml.attributeName» = «IF xml.annotedName != null»«xml.annotedName»@ «ENDIF»«xml.name»'''
	def dispatch String compile(XMLAttribute3 xml)'''«IF xml.attributeName != null»«xml.attributeName»@«ENDIF»_ = «
		IF xml.annotedName != null»«xml.annotedName»@ «ENDIF»«xml.name»'''
	def dispatch String compile(XMLChilds xml)'''[«xml.terms.map[compile].join(",")»]'''
/////////////////////////////////////////////////////////////////////////////////////////////////////
///Transformation//////////////////////////////////////////////////////////////////////////////////////////////////
def dispatch String compile(Transformation t)'''
%transformation «t.name» («t.args.compile») : "«t.eResource.dirName»«t.fileFrom»" -> "«t.eResource.dirName»«t.fileTo»" {
	«t.elementaryTranformations.map[compile].join('\n')»
}
'''
def dispatch String compile(ElementaryTransformation et)'''
	definition «et.name» traversal «et.implement.compile» {
		«et.elementaryTransformationRules.map[compile].join("\n")»
	}
'''
def dispatch String compile(ElementaryTransformationRule etr)'''«etr.pattern.compile»->{
	«etr.statements.map[fullCompile].join('\n')»
}'''
/////////////////////////////////////////////////////////////////////////////////////////////////////

}
